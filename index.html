<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>txt2img</title>
  <link rel="stylesheet" href="./style.css">
<script type="text/javascript"
	src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript"
	src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js"></script>
<link rel="stylesheet" type="text/css"
	href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.1/themes/base/jquery-ui.css"/>
</head>
<body>
<div class=editor>
    <textarea
        id=textarea
        spellcheck=false
        oninput="update(this.value)"
      placeholder="Write your text"
      autofocus
    ></textarea>
</div>
<div id="shadercollab"></div>

<script id="vertex" type="x-shader/x-vertex">
varying vec2 texCoordVarying;
	
void main() {
	texCoordVarying = uv;
	
	gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);
}
</script>

<script id="copy" type="x-shader/x-fragment">
varying vec2 texCoordVarying;
uniform sampler2D channel0;
	
vec2 rotate(vec2 v, float a) {
	return mat2(cos(a), -sin(a), sin(a), cos(a))*v;
}

void main() {
	vec4 inText = texture2D(channel0,texCoordVarying);
	// vec4 inText2 = texture2D(channel0,texCoordVarying * 0.9);
	
	gl_FragColor = inText;
}
</script>

<script id="diffusion" type="x-shader/x-fragment">
  uniform sampler2D webcam;
  uniform sampler2D backbuffer;
  uniform float time;
  uniform float resoluton;
  uniform int rule[18];
  uniform float offset1;
  uniform float offset2;
  uniform float offset3;
  uniform float offset4;
  uniform bool modo1;
 

varying vec2 texCoordVarying;
uniform vec2 resolution;

const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 hsv2rgb(vec3 c) {
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
  vec3 hueShift( vec3 color, float hueAdjust ){
      const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);
      const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);
      const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);
      const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);
      const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);
      const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);
      float   YPrime  = dot (color, kRGBToYPrime);
      float   I       = dot (color, kRGBToI);
      float   Q       = dot (color, kRGBToQ);
      float   hue     = atan (Q, I);
      float   chroma  = sqrt (I * I + Q * Q);
      hue += hueAdjust;
      Q = chroma * sin (hue);
      I = chroma * cos (hue);
      vec3    yIQ   = vec3 (YPrime, I, Q);
      return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );
  }

precision highp float;

#define M_PI 3.1415926535897932384626433832795

  vec3 satur(vec3 cin, float amount ){
      const vec3 W = vec3(0.2125, 0.7154, 0.0721);
      vec3 intensity = vec3(dot(cin.rgb, W));
      return mix(intensity, cin.rgb, amount);
  }

  vec2 modulate(vec2 st, vec2 tex, float amount){
      return st+ tex*amount;
  }
  vec3 modulate(vec3 st, vec3 tex, float amount){
      return st+ tex*amount;
  }

  float luma(vec3 color) {
      return dot(color, vec3(0.299, 0.587, 0.114));
  }

void main() {
  vec2 pixel = gl_FragCoord.xy / resolution;
  vec3 finalColor;
  vec3 webcamCapture = texture2D(webcam, pixel).rgb;
  vec3 lastFrame = texture2D(backbuffer, pixel + vec2(0.0, 0.)).rgb;
  vec3 color = texture2D(backbuffer, pixel).rgb;

    float pixelSize = 1.+mix(-.5,200.,offset2);
    vec2 pos =
        vec2(floor(gl_FragCoord.x / pixelSize) * pixelSize + pixelSize / 2.0,
             floor(gl_FragCoord.y / pixelSize) * pixelSize + pixelSize / 2.0);

    float threshold = 0.49 +mix(-.5,.5,offset1);
    float neighbors = 0.0;

    for (float y = -1.0; y <= 1.0; y++) {
        for (float x = -1.0; x <= 1.0; x++) {
            vec4 pixelC = texture2D(
                backbuffer, (pos + vec2(x * pixelSize, y * pixelSize)) / resolution);
            neighbors += step(threshold, pixelC.r);
        }
    };

    float status = step(threshold, color.r);
    neighbors -= status;
    
    //gl_FragColor = vec4(mix(1.-1.2*webcamCapture,max(lastFrame,webcamCapture), 0.9)-0.8*color,1.);

    
    int ruleIndex = 2*int(neighbors);
    int ruleWhen = rule[ruleIndex];
    int ruleThen = rule[ruleIndex+1];

    float newState = float(!bool(ruleWhen == int(status)) || bool(ruleThen));

    color = vec3(newState)*0.5+0.5*webcamCapture;

    
    vec3 render = webcamCapture + lastFrame*newState*0.2;

    float rnd1 = fract(sin(dot(pos + time * 0.001, vec2(14.9898,78.233))) * 43758.5453);
    render = mix(render, lastFrame, step(0.5, rnd1));

   if (render.b > 0.004) {
        render = max(render - 0.004, 0.25);
    }

   //vec3 webAfter = texture2D(webcam, pixel+color.rg*0.05).rgb;
    
    render = mix(render, mix(1.-1.2*webcamCapture,max(lastFrame,webcamCapture), 0.9)-0.8*color, float(modo1));

    render = satur(render, mix(0.,3.,offset3));
    render = hueShift(render, mix(0.,3.,offset4));

    gl_FragColor = vec4(render,1.);

}
</script>
<!-- partial -->
<script type="text/javascript" src="libs/dat.gui.min.js"></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'></script><script  src="./script.js"></script>
</body>
</html>
